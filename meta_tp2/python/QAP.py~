import random
import sys
import gc
random.seed()
sys.setrecursionlimit(20000)

class Solution:
    def __init__(self, objects: list):
        self.__objects__ = objects
        self.__n__ = len(objects)

    def objects(self):
        return self.__objects__

    def n(self):
        return self.__n__

    def neighbors(self):
        ns = []
        for i in range(0, self.__n__ - 1):
            for j in range(i + 1, self.__n__):
                n = self.__objects__[:]
                n[i] = self.__objects__[j]
                n[j] = self.__objects__[i]
                ns.append(Solution(n))
        return ns

    def neighbor(self,i,j):
        n = self.__objects__[:]
        n[i]=self.__objects__[j]
        n[j]=self.__objects__[i]
        return Solution(n)

    def __repr__(self):
        return str(self.__objects__)
    def __getitem__(self,i):
        return self.__objects__[i]

def rand_solution(n: int):
    sol = []
    for i in range(0,n):
        sol.append(i+1)
    sol = Solution(sol)
    for i in range(0,n):
        x = random.randint(0,n-1)
        y = random.randint(0,n-1)
        sol = sol.neighbor(x,y)
    return sol

class TabuMatrix:
    def __init__(self, n:int,st_length: int):
        self.__l__=st_length
        self.__st_matrix__=[]
        self.__lt_matrix__=[]
        self.__n__=n
        self.__max_history__=n*n
        self.__t__ = 1
        for i in range(0,n):
            self.__st_matrix__.append([])
            self.__lt_matrix__.append([])
            for j in range(0,n):
                self.__st_matrix__[i].append(0)
                self.__lt_matrix__[i].append(0)
    def step(self):
        self.__t__+=1

    def status(self,n:int, j:int):
        return self.__t__> self.__st_matrix__[n-1][j]
    def is_mandatory(set,n:int, j:int):
        return self.__t__> self.__st_matrix__[n-1][j]+self.__max_history__

    def tabu(self,s: Solution,i: int, j:int):
        t = self.__t__
        self.__t__+=1
        self.__st_matrix__[s[i]-1][i]=t+self.__l__
        self.__st_matrix__[s[j]-1][j]=t+self.__l__
        self.__lt_matrix__[s[i]-1][j]=self.__t__
        self.__lt_matrix__[s[j]-1][i]=self.__t__



    def __repr__(self):
        s = '\nShort term\n'
        for i in range(0,self.__n__+2):
            for j in range(0,self.__n__+1):
                if i<2 and j<1:
                    s+='  '
                elif i==0 and j>0:
                    s+=' '+str(j)+' '
                elif i==1 and j>0:
                    s+='___'
                elif i>1 and j==0:
                    s+=str(i-1)+'|'
                elif i>1 and j>0:
                    s+=' '+str(self.__st_matrix__[i-2][j-1])+' '
            s+='\n'
        s+='\n\nLong term\n'
        for i in range(0,self.__n__+2):
            for j in range(0,self.__n__+1):
                if i<2 and j<1:
                    s+='  '
                elif i==0 and j>0:
                    s+='  '+str(j)+'  '
                elif i==1 and j>0:
                    s+='_____'
                elif i>1 and j==0:
                    s+=str(i-1)+'|'
                elif i>1 and j>0:
                    s+=' '+str(self.__lt_matrix__[i-2][j-1]/self.__t__)+' '
            s+='\n'
        return s

class QAP:
    def __init__(self, n: int, D: list, W: list, tabu_length: int=10):
        self.__n__ = n
        self.__w__ = W
        self.__d__ = D
        self.__tabu__= TabuMatrix(n,tabu_length)
        self.__l__ = tabu_length

    def __psi__(self, i: int, s: Solution):
        return s.objects().index(i + 1)

    def n(self):
        return self.__n__

    def d(self):
        return self.__d__

    def w(self):
        return self.__w__

    def reset(self):
        self.__tabu__ = TabuMatrix(n,self.__l__)

    def fitness(self, s: Solution):
        I = 0
        n = s.n()
        for i in range(0, n):
            di = self.__psi__(i, s)
            for j in range(i+1, n):
                w = self.__w__[i][j]
                dj = self.__psi__(j, s)
                d = self.__d__[di][dj]
                I += w * d
        return 2*I

    def delta_fitness(self, s: Solution, i: int, j: int):
        delta = 0
        si = s[i]-1
        sj = s[j]-1
        di = self.__psi__(si, s)
        dj = self.__psi__(sj, s)
        for k in range(0,s.n()):
            if k==si or k==sj:
                continue
            dk = self.__psi__(k,s)
            dd=(self.__w__[k][si]-self.__w__[k][sj])*(self.__d__[dk][di]-self.__d__[dk][dj])
            delta+=dd
        return 2*delta

    def U(self, s: Solution, current_fitness: int, best_f: int, best_s: Solution, steps: int = 50):
        if steps <= 0 :
            return best_s, best_f
        gc.collect()
        min_n = None
        min_f = sys.maxsize
        perm = [-1,-1]
        for i in range(0,s.n()-1):
            for j in range(i+1,s.n()):
                f =current_fitness-self.delta_fitness(s,i,j)
                if f<min_f and f<best_f:
                    min_n =s.neighbor(i,j)
                    min_f = f
                    perm=[i,j]
                elif self.__tabu__.status(s[i],j) and self.__tabu__.status(s[j],i):
                    if f < min_f:
                        min_n =s.neighbor(i,j)
                        min_f = f
                        perm=[i,j]
        if min_f < best_f:
            best_f = min_f
            best_s = min_n
        if min_n is None:
            self.__tabu__.step()
            return self.U(s,current_fitness, best_f, best_s, steps - 1)
        self.__tabu__.tabu(s,perm[0],perm[1])
        return self.U(min_n,min_f, best_f, best_s, steps - 1)
